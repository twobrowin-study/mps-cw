/*!
\file
  \bref Точная задержка
  \author Дубровин Егор гр. ИУ6-72
  \date Октябрь 2018 года

  Файл содержит реализацию методов точной задержки
*/
#include "delay.h"

/*!
  \bref Инициализация точную задержку
  \return Статус завершения

  Содержит инизиализацию PLL, выбор способа тактирования и инициализацию таймера 1
*/
END_STATUS delay_init(void) {
  MDR_RST_CLK->HS_CONTROL = 0x00000001; // Включение HSE, режим осциллятора (8МГц)
  while((MDR_RST_CLK->CLOCK_STATUS&0x04) == 0x00); // Ожидание выхлда HSE в штатный режим
  MDR_EEPROM->CMD = 5<<3;

  // Инициализация PLL
  /*!
  * Выбираем в качестве источника опорного сигнала HSE (внешний) с делением на 1.
  * Умножаем входную частоту на 9 (8 МГц * 9 = 72 МГц)
  */
  MDR_RST_CLK->PLL_CONTROL = (8<<8) | (1<<2); // Включение CPU_PLL к-та умножения
  while((MDR_RST_CLK->CLOCK_STATUS&0x02)==0x00); // Ожидание выхода CPU_PLL в штатный режим

  MDR_EEPROM->CMD = 3<<3; // Задержка для обращения к flash-памяти Delay = 3; Обход проблемы ядра

  MDR_RST_CLK->CPU_CLOCK |= 0x00000106; // Задать HCLK = CPU_C3 = CPU_C2 = CPU_PLL; CPU_C1 = HSE
  SystemCoreClockUpdate();

  // Инициализация Таймера 1
  /*!
  * Устанавливаем предделитель на 4 (72 МГц / 4 = 18 МГц)
  */
  MDR_RST_CLK->PER_CLOCK |= (1<<14); // Разрешение такстирования блока таймера 1
  MDR_RST_CLK->TIM_CLOCK |= (1<<24) | 0x2; // Разрешение тактовой частоты для таймера 1 и делителя тактовой частоты на 4

  return END_OK;
}

/*!
  \bref Точная задержка
  \return Статус завершения
  \param ms - время задежки в милисекундах

  Содержит организацию времени задержки и ождание её окончания
*/
END_STATUS delay(uint ms) {
  MDR_TIMER1->CNTRL = (1<<3); // Счёт таймера вниз
  MDR_TIMER1->PSG = 18000; // Предделитель (на вход предделителя поступает 18 МГц)
  MDR_TIMER1->CNT = ms; // Начальное значение (на вход таймера поступает 1кГц)
  MDR_TIMER1->CNTRL |= 0x1; // Разрешение работы таймера
  while(MDR_TIMER1->CNT); // Ожидание окончания счёта
  return END_OK;
}
